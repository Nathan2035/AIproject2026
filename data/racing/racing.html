<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>簡單賽車遊戲</title>
<style>
/* 防止 iOS 橡皮筋回彈與捲動 */
html, body { 
    margin:0; padding:0; background:#fff; font-family:monospace; 
    overflow: hidden; height: 100%; width: 100%; position: fixed;
}
#gameWrapper { 
    width:100%; height: 100dvh; /* 使用 dvh 確保包含手機瀏覽器工具列的高度 */
    max-width:400px; margin:0 auto; 
    display: flex; flex-direction: column; justify-content: flex-start; align-items: center;
    box-sizing: border-box; padding: 5px;
}
#game { 
    width:100%; flex: 1; /* 自動填滿剩餘空間 */
    background:#555; border:4px solid #000; position:relative; overflow:hidden; touch-action:none; 
}
canvas { position:absolute; top:0; left:0; z-index:1; width:100%; height:100%; }

/* 以下維持原樣，但修正元件在伸縮畫面下的表現 */
.player, .enemy { position:absolute; z-index:2; }
.player { bottom:30px; width:50px; height:100px; }
.playerImg { position:absolute; top:10px; left:3px; width:55px; height:93px; background-image:url('You.png'); background-size:cover; background-position:center; pointer-events:none; filter: drop-shadow(6px 6px 8px rgba(0,0,0,0.5));}
.enemy { width:50px; height:100px; position:absolute; }
.enemyImg { position:absolute; top:10px; left:5px; width:50px; height:88px; background-size:cover; background-position:center; pointer-events:none; filter: drop-shadow(6px 6px 8px rgba(0,0,0,0.5));}
.hitbox { position:absolute; border:2px dashed red; border-radius:18px; pointer-events:none; z-index:10; }
#adBoard { position:absolute; width:65px; height:50px; background:#fff; border:2px solid #000; color:#000; display:flex; justify-content:center; align-items:center; font-weight:bold; font-size:18px; z-index:5; display:none; }
#controls { width: 100%; display:flex; justify-content:space-between; align-items:center; margin-top:10px; margin-bottom: 10px; }
#ledDisplay { display:flex; gap:5px; padding:4px 8px; border:2px solid #000; background:#000; border-radius:5px; align-items:center; }
.digit { display:inline-block; min-width:14px; padding:1px 2px; background:#fff; color:#000; font-size:16px; border:1px solid #000; text-align:center; }
.text { display:inline-block; color:#fff; font-size:16px; }
#startBtn { padding:8px 16px; font-size:16px; cursor:pointer; background:#0a0; border:none; border-radius:5px; color:#fff; }
#startBtn.disabled { background:#444; cursor:not-allowed; }
#gameOver { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:48px; color:yellow; z-index:3; display:none; pointer-events:none; white-space: nowrap; }
#backBtn{ position:fixed; top:10px; left:10px; padding:6px 12px; font-size:14px; background:rgba(255,255,255,0.8); border:2px solid #ccc; border-radius:6px; cursor:pointer; color:#333; z-index:9999; }
#highScoreDisplay { width: 100%; display:flex; justify-content:center; gap:1px; padding:4px 0; border:2px solid #000; background:#000; border-radius:5px; align-items:center; margin: 5px 0; }
</style>
</head>
<body>

<button id="backBtn">返回</button>

<div id="gameWrapper">
  <div id="highScoreDisplay"></div>
  <div id="game">
    <canvas id="roadCanvas" width="400" height="600"></canvas>
    <div class="player" id="player"><div class="playerImg"></div></div>
    <div id="gameOver">撞到了</div>
    <div id="adBoard">恭喜達成1KM</div>
  </div>
  <div id="controls">
    <div id="ledDisplay">
      <div id="speedDisplay"></div>
      <div id="kmDisplay"></div>
    </div>
    <button id="startBtn">開始</button>
  </div>
</div>

<script>
backBtn.onclick=()=>{window.history.back();};

const game = document.getElementById('game');
const player = document.getElementById('player');
const startBtn = document.getElementById('startBtn');
const gameOverText = document.getElementById('gameOver');
const canvas = document.getElementById('roadCanvas');
const ctx = canvas.getContext('2d');
const kmDisplay = document.getElementById('kmDisplay');
const speedDisplay = document.getElementById('speedDisplay');
const adBoard = document.getElementById('adBoard');
const highScoreDisplay = document.getElementById('highScoreDisplay');

const gameWidth = 400, gameHeight = 600, playerWidth=50;
let playerPos = 175; player.style.left = playerPos+'px';
let targetPlayerPos = playerPos;
const PLAYER_MOVE_SPEED = 150;
let enemies = [];
let gameRunning=false;
let km=0, speed=0, displayKm=0, targetSpeed=100;
const acceleration=100/6;
let lastTimestamp=0;
let enemySpawnTimer = 0;

// LocalStorage 讀取最高紀錄
let highScore = parseFloat(localStorage.getItem('racingGame_highScore')) || 0;

const PLAYER_HITBOX_SCALE = 0.8;
const ENEMY_HITBOX_SCALE = 0.8;
const HITBOX_RADIUS = 18;
const SHOW_HITBOX = false;

const PX_PER_M = 19.5;
const WHITE_LINE_KM = 0.004;
const GAP_KM = 0.006;
const WHITE_LINE_PX = WHITE_LINE_KM * 1000 * PX_PER_M;
const GAP_PX = GAP_KM * 1000 * PX_PER_M;

let lineOffset=0;
const LEFT_MARGIN = 50 + 20;
const RIGHT_MARGIN = gameWidth - 50 - 20;
const LINE_WIDTH = 5;
const PLAYER_HITBOX_OFFSET = (playerWidth - PLAYER_HITBOX_SCALE*playerWidth)/2;
const ENEMY_HITBOX_OFFSET = (50 - ENEMY_HITBOX_SCALE*50)/2;
const PLAYER_MIN_X = LEFT_MARGIN - PLAYER_HITBOX_OFFSET;
const PLAYER_MAX_X = RIGHT_MARGIN - playerWidth - LINE_WIDTH + PLAYER_HITBOX_OFFSET - 4;
const ENEMY_MIN_X = LEFT_MARGIN - ENEMY_HITBOX_OFFSET;
const ENEMY_MAX_X = RIGHT_MARGIN - 50 - LINE_WIDTH + ENEMY_HITBOX_OFFSET - 4;

let nextAdKm = 1;
let adBoardActive = false;
let adBoardPosY = -50;

let audioCtx, engineOsc, engineNoise, engineGain, engineFilter, engineRunningStatus=false;
let crashBuffer = null;

function loadCrashSound(){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  fetch('Crash_sound.mp3')
    .then(response => response.arrayBuffer())
    .then(data => audioCtx.decodeAudioData(data))
    .then(buffer => { crashBuffer = buffer; })
    .catch(err => console.error('音效載入失敗'));
}

function playCrashSound(){ if(!crashBuffer) return; const crashSource = audioCtx.createBufferSource(); crashSource.buffer = crashBuffer; crashSource.connect(audioCtx.destination); crashSource.start(); }

function startEngineSound() {
  if(engineRunningStatus) return;
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  loadCrashSound();
  engineOsc = audioCtx.createOscillator(); engineOsc.type = 'sawtooth';
  const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for(let i=0;i<data.length;i++) data[i] = Math.random()*2-1;
  engineNoise = audioCtx.createBufferSource(); engineNoise.buffer = buffer; engineNoise.loop = true;
  engineGain = audioCtx.createGain(); engineGain.gain.value = 0.15;
  engineFilter = audioCtx.createBiquadFilter(); engineFilter.type = 'lowpass'; engineFilter.frequency.value = 800;
  engineOsc.connect(engineFilter); engineNoise.connect(engineFilter); engineFilter.connect(engineGain); engineGain.connect(audioCtx.destination);
  engineOsc.frequency.value = speedToHz(speed);
  engineOsc.start(); engineNoise.start(); engineRunningStatus = true;
}

function stopEngineSound(){ if(!engineRunningStatus) return; engineOsc.stop(); engineNoise.stop(); engineRunningStatus = false; }
function speedToHz(spd) { return 100 + spd * 5; }
function updateEngineSound(delta){ if(!engineRunningStatus) return; engineOsc.frequency.setTargetAtTime(speedToHz(speed), audioCtx.currentTime, 0.1); engineFilter.frequency.setTargetAtTime(500 + speed*1.5, audioCtx.currentTime, 0.1); engineGain.gain.setTargetAtTime(0.05 + speed/300*0.25, audioCtx.currentTime, 0.1); }

function displayLED(container,text){ container.innerHTML=''; for(let c of text){ const span=document.createElement('span'); span.className = /[0-9]/.test(c)?'digit':'text'; span.textContent=c; container.appendChild(span); } }
function updateInfo(){ while(km >= displayKm + 0.1) displayKm += 0.1; const kmFixed = displayKm.toFixed(1); const [kmInteger, kmDecimal] = kmFixed.split('.'); displayLED(speedDisplay, `${Math.floor(speed).toString().padStart(3,'0')} KM/H`); displayLED(kmDisplay, `${kmInteger.padStart(3,'0')}.${kmDecimal} KM`); }
function updateHighScoreDisplay() { const roundedHigh = highScore.toFixed(1); const [intPart, decPart] = roundedHigh.split('.'); displayLED(highScoreDisplay, `最高紀錄 : ${intPart.padStart(3,'0')}.${decPart} KM`); }

// 關鍵優化：座標縮放修正，確保 touch 位置準確
function handleInput(e) {
    if(!gameRunning) return;
    const rect = game.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const scaleX = gameWidth / rect.width;
    targetPlayerPos = (clientX - rect.left) * scaleX;
}

game.addEventListener('mousemove', handleInput);
game.addEventListener('touchmove', (e) => { handleInput(e); e.preventDefault(); }, {passive: false});

function getScaledRect(rect, scale){
    const gRect = game.getBoundingClientRect();
    const sX = gameWidth / gRect.width;
    const sY = gameHeight / gRect.height;
    const left = (rect.left - gRect.left) * sX;
    const top = (rect.top - gRect.top) * sY;
    const width = rect.width * sX;
    const height = rect.height * sY;
    const w = width * scale; const h = height * scale;
    const cx = left + width / 2; const cy = top + height / 2;
    return {left: cx-w/2, right: cx+w/2, top: cy-h/2, bottom: cy+h/2};
}

function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
function pointToRectDist(px, py, rect){ const cx = clamp(px, rect.left, rect.right); const cy = clamp(py, rect.top, rect.bottom); const dx = px-cx; const dy = py-cy; return Math.sqrt(dx*dx + dy*dy); }
function roundedRectCollision(a,b,r){ const aCorners=[[a.left+r,a.top+r],[a.right-r,a.top+r],[a.left+r,a.bottom-r],[a.right-r,a.bottom-r]]; const bCorners=[[b.left+r,b.top+r],[b.right-r,b.top+r],[b.left+r,b.bottom-r],[b.right-r,b.bottom-r]]; for(const [ax,ay] of aCorners) for(const [bx,by] of bCorners) if((ax-bx)**2+(ay-by)**2<=(r*2)**2) return true; for(const [ax,ay] of aCorners) if(pointToRectDist(ax,ay,b)<=r) return true; for(const [bx,by] of bCorners) if(pointToRectDist(bx,by,a)<=r) return true; return false; }

function spawnEnemy(){ 
    let laneX, topY; 
    laneX = ENEMY_MIN_X + Math.random()*(ENEMY_MAX_X - ENEMY_MIN_X); 
    topY = -150; 
    const enemy = document.createElement('div'); enemy.classList.add('enemy'); enemy.style.left = laneX + 'px'; enemy.style.top = topY + 'px'; 
    const enemyImg = document.createElement('div'); enemyImg.className = 'enemyImg'; 
    const rand = Math.random(); 
    if(rand < 0.33) enemyImg.style.backgroundImage = "url('E1.png')"; 
    else if(rand < 0.66) enemyImg.style.backgroundImage = "url('E2.png')"; 
    else enemyImg.style.backgroundImage = "url('E3.png')"; 
    enemy.appendChild(enemyImg); 
    enemy.vx = (Math.random()*0.6 - 0.3); 
    enemy.targetSpeed = targetSpeed * (0.7 + Math.random()*0.2); 
    enemy.speed = enemy.targetSpeed * 0.6; 
    enemy.acceleration = 10;
    game.appendChild(enemy); enemies.push(enemy); 
}

function clearEnemies(){ enemies.forEach(e=>e.remove()); enemies=[]; }

let fireworks = [];
let fireworkText = null;
let fireworkTimer = 0;
function spawnFirework(x, y, kmValue){
    fireworks = []; fireworkTimer = 5; fireworkText = `達成 ${kmValue}KM`;
    for(let i=0;i<30;i++){
        const angle = Math.random()*2*Math.PI; const speedVal = 50 + Math.random()*100;
        fireworks.push({x:x, y:y, vx:Math.cos(angle)*speedVal, vy:Math.sin(angle)*speedVal, life:2, color:`hsl(${Math.random()*360},100%,50%)`});
    }
}

function updateFireworks(delta){
    if(fireworkTimer<=0) return; fireworkTimer -= delta;
    fireworks.forEach(p=>{ p.x += p.vx*delta; p.y += p.vy*delta; p.vy += 20*delta; p.life -= delta/5; });
}

function drawFireworks(){
    if(fireworkTimer<=0) return;
    fireworks.forEach(p=>{ if(p.life > 0) { ctx.fillStyle=p.color; ctx.globalAlpha=p.life; ctx.beginPath(); ctx.arc(p.x,p.y,3,0,2*Math.PI); ctx.fill(); }});
    if(fireworkText){ ctx.globalAlpha = Math.sin(Date.now()/100)*0.5+0.5; ctx.fillStyle='yellow'; ctx.font='24px monospace'; ctx.textAlign='center'; ctx.fillText(fireworkText, gameWidth/2, gameHeight/2); }
    ctx.globalAlpha=1;
}

function drawRoad(){
    ctx.clearRect(0,0,gameWidth,gameHeight);
    ctx.fillStyle='#C2B280'; ctx.fillRect(0,0,LEFT_MARGIN,gameHeight); ctx.fillRect(RIGHT_MARGIN,0,gameWidth-RIGHT_MARGIN,gameHeight);
    ctx.fillStyle='#555'; ctx.fillRect(LEFT_MARGIN,0,RIGHT_MARGIN-LEFT_MARGIN,gameHeight);
    ctx.strokeStyle='#fff'; ctx.lineWidth=LINE_WIDTH;
    ctx.beginPath(); ctx.moveTo(LEFT_MARGIN,0); ctx.lineTo(LEFT_MARGIN,gameHeight); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(RIGHT_MARGIN,0); ctx.lineTo(RIGHT_MARGIN,gameHeight); ctx.stroke();
    ctx.setLineDash([WHITE_LINE_PX,GAP_PX]);
    ctx.beginPath(); ctx.moveTo(gameWidth/2,lineOffset); ctx.lineTo(gameWidth/2,gameHeight+lineOffset); ctx.stroke();
    ctx.setLineDash([]);
}

function gameLoop(timestamp){
    if(!lastTimestamp) lastTimestamp=timestamp;
    const delta = (timestamp - lastTimestamp)/1000; lastTimestamp = timestamp;

    if(km >= 1 && targetSpeed===100) targetSpeed=150;
    if(km >= 2 && targetSpeed===150) targetSpeed=200;
    if(speed<targetSpeed){ speed += acceleration*delta; if(speed>targetSpeed) speed=targetSpeed; }
    km += speed*delta/3600;

    const roadSpeedPxPerSec = (speed*1000/3600)*PX_PER_M;
    lineOffset += roadSpeedPxPerSec*delta;
    if(lineOffset >= WHITE_LINE_PX+GAP_PX) lineOffset -= WHITE_LINE_PX+GAP_PX;

    drawRoad(); updateInfo(); updateFireworks(delta); drawFireworks();

    if(Math.floor(km) === nextAdKm){
        const currentKm = nextAdKm; adBoardActive = true; adBoardPosY = -50; adBoard.style.display = 'flex'; adBoard.style.left = RIGHT_MARGIN + 5 + 'px';
        adBoard.textContent = `${currentKm}KM`; spawnFirework(gameWidth/2, gameHeight/2, currentKm); nextAdKm++;
    }

    if(adBoardActive){ adBoardPosY += roadSpeedPxPerSec*delta; adBoard.style.top = adBoardPosY+'px'; if(adBoardPosY>gameHeight){ adBoardActive=false; adBoard.style.display='none'; } }

    const diff = targetPlayerPos - (playerPos+playerWidth/2);
    if(Math.abs(diff)>1){ const move = Math.sign(diff)*Math.min(Math.abs(diff), PLAYER_MOVE_SPEED*delta); playerPos+=move; playerPos=clamp(playerPos,PLAYER_MIN_X,PLAYER_MAX_X); player.style.left=playerPos+'px'; }

    const pBCR = player.getBoundingClientRect();
    const playerRect = getScaledRect(pBCR, PLAYER_HITBOX_SCALE);

    enemySpawnTimer += delta;
    let currentInterval = (targetSpeed >= 200) ? 1 : (targetSpeed >= 150 ? 1.5 : 2);
    if(enemySpawnTimer>=currentInterval){ spawnEnemy(); enemySpawnTimer=0; }

    enemies.forEach((enemy,idx)=>{
        if(enemy.speed<enemy.targetSpeed){ enemy.speed+=enemy.acceleration*delta; }
        const relativeSpeed = enemy.speed-speed;
        const relativeMovePx = (relativeSpeed*1000/3600)*PX_PER_M*delta;
        let top = parseFloat(enemy.style.top)-relativeMovePx;
        enemy.style.top = top+'px';
        
        let left=parseFloat(enemy.style.left)+enemy.vx*delta*60;
        left=clamp(left,ENEMY_MIN_X,ENEMY_MAX_X); enemy.style.left=left+'px';

        if(top > gameHeight + 100 || top < -300){ enemy.remove(); enemies.splice(idx,1); return; }
        
        const enemyRect = getScaledRect(enemy.getBoundingClientRect(), ENEMY_HITBOX_SCALE);
        if(roundedRectCollision(playerRect, enemyRect, HITBOX_RADIUS)){
            gameOverText.style.display='block'; gameRunning=false; startBtn.disabled=false; stopEngineSound(); playCrashSound();
        }
    });

    adjustEnemyDistances();
    if(engineRunningStatus) updateEngineSound(delta);
    
    const roundedKm = parseFloat(displayKm.toFixed(1));
    if(roundedKm>highScore){ highScore=roundedKm; localStorage.setItem('racingGame_highScore', highScore); updateHighScoreDisplay(); }
    
    if(gameRunning) requestAnimationFrame(gameLoop);
}

startBtn.addEventListener('click', ()=>{
    if(gameRunning) return;
    startBtn.disabled=true; clearEnemies(); playerPos=175; targetPlayerPos=175; player.style.left=playerPos+'px';
    gameOverText.style.display='none'; km=0; speed=0; displayKm=0; targetSpeed=100; lastTimestamp=0; enemySpawnTimer=0; nextAdKm=1; adBoardActive=false;
    updateInfo(); gameRunning=true; startEngineSound(); requestAnimationFrame(gameLoop);
});

// 初始化
drawRoad(); updateInfo(); updateHighScoreDisplay();
</script>

</body>
</html>